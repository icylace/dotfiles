-- https://typeclasses.com/ghci/config
-- https://downloads.haskell.org/~ghc/master/users-guide/using-warnings.html
-- https://medium.com/mercury-bank/enable-all-the-warnings-a0517bc081c3
-- https://gist.github.com/Pitometsu/0b0d04706e671172ed3b78309b14b43d
-- https://gist.github.com/ChShersh/9111d97578413323ba1b191299c54235

-- Options apparently get processed in this order:
--   1. A config.yaml.
--   2. A project's stack.yaml.
--   3. `--ghc-options` when running`stack ghci` on the command line.
--   4. `.ghci` settings (this file).

-- -----------------------------------------------------------------------------
--  Setup pretty-printing of `Show` instances.
-- -----------------------------------------------------------------------------

-- https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html?highlight=interactive-print#ghc-flag--interactive-print%20⟨expr⟩
-- https://teh.id.au/posts/2017/02/13/interactive-print/
-- https://github.com/thumphries/dotfiles/blob/b4011c8305409e3b1f8aab547895f3a22c8f7ec2/ghc/.ghc/ghci.conf

import           Text.Show.Pretty (ppShow)
import qualified Language.Haskell.HsColour           as H
import qualified Language.Haskell.HsColour.Colourise as HC
import qualified Language.Haskell.HsColour.Output    as HO

:{
colorAnakiwa        = HC.Rgb 163 255 235
colorHavelockBlue   = HC.Rgb 71 150 215
colorMariner        = HC.Rgb 39 115 178
colorMariner2       = HC.Rgb 44 130 201
colorMulledWine     = HC.Rgb 70 70 104
colorNewYorkPink    = HC.Rgb 214 126 130
colorWildStrawberry = HC.Rgb 255 56 165
colorViking         = HC.Rgb 86 216 188

-- http://hackage.haskell.org/package/hscolour-1.24.4/docs/src/Language-Haskell-HsColour-Classify.html
myColourPrefs = HC.defaultColourPrefs
  { HC.char             = [HC.Foreground colorAnakiwa]          -- Character.
  , HC.comment          = [HC.Foreground colorMulledWine]       -- Comment.
  , HC.conid            = [HC.Foreground colorHavelockBlue]     -- Constructor.
  , HC.conop            = [HC.Foreground colorHavelockBlue]     -- Cons operator.
  , HC.cpp              = [HC.Foreground colorHavelockBlue]     -- Leading hash tag.
  , HC.definition       = [HC.Foreground HC.White]              -- ???
  , HC.keyglyph         = [HC.Foreground colorMariner]          -- Built-in symbol.
  , HC.keyword          = [HC.Foreground colorMariner]          -- Built-in keyword.
  , HC.layout           = [HC.Foreground colorMariner2]         -- Grouping character.
  , HC.number           = [HC.Foreground colorWildStrawberry]   -- Number.
  , HC.selection        = [HC.Foreground HC.White]              -- ???
  , HC.string           = [HC.Foreground colorViking]           -- String.
  , HC.variantselection = [HC.Foreground HC.White]              -- ???
  , HC.varid            = [HC.Foreground colorNewYorkPink]      -- Variable or function.
  , HC.varop            = [HC.Foreground colorNewYorkPink]      -- Operator or inlined function.
  }

prettyPrint :: Show a => a -> IO ()
prettyPrint = putStrLn . H.hscolour (H.TTYg HO.XTerm256Compatible) myColourPrefs False False "" False . ppShow
:}

-- Once we make use of the pretty-printing-related modules we can remove from
-- them from the scope of the prompt without losing their effect.
:m - Text.Show.Pretty Language.Haskell.HsColour Language.Haskell.HsColour.Colourise Language.Haskell.HsColour.Output

:def no-pretty \_ -> return $ ":set -interactive-print System.IO.print"
:def pretty \_ -> return $ ":set -interactive-print prettyPrint"

:pretty

-- -----------------------------------------------------------------------------
--  Setup a custom prompt.
-- -----------------------------------------------------------------------------

:{
colorAvocado  = "\ESC[38;2;150;150;100m"
colorDoveGray = "\ESC[38;2;100;100;100m"
colorHotPink  = "\ESC[38;2;255;105;180m"
colorAmethyst = "\ESC[38;2;160;80;200m"
reset         = "\ESC[m"

showThe :: Show a => String -> a -> String
showThe color x = color ++ show x ++ reset

showThem :: String -> [String] -> String
showThem color xs = color ++ foldr1 ((++) . (++ " ")) xs ++ reset

showOneOf :: String -> String -> Int -> String
showOneOf color xs n = color ++ [xs !! mod n (length xs)] ++ "  " ++ reset

prompt :: [String] -> Int -> String
prompt xs n = "\n"
  ++ showThe colorAvocado n ++ " " ++ showThem colorDoveGray xs ++ "\n"
  ++ showOneOf colorHotPink "λ𝞴ᴧ𝚲𝛌𝛬Λ𝜆𝜦𝝀𝝠𝝺ƛ𝞚" n

continuationPrompt :: [String] -> Int -> String
continuationPrompt _ n = showOneOf colorAmethyst "⋮⁞┆┇┋┊" n

(.:) :: (a -> b) -> (c -> d -> a) -> c -> d -> b
(.:) = (.) . (.)
:}

:set prompt-function return .: prompt
:set prompt-cont-function return .: continuationPrompt

-- -----------------------------------------------------------------------------
--  Setup the ability to search Hoogle.
-- -----------------------------------------------------------------------------

hoogle = return . (++) ":! stack hoogle -- "
hoogleInfo = return . (++) ":! stack hoogle -- --info "

:def hoogle hoogle
:def hoogle-info hoogleInfo

:def ho hoogle
:def hoi hoogleInfo

-- -----------------------------------------------------------------------------

-- Show character ranges for errors.
-- https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html#ghc-flag--ferror-spans
:set -ferror-spans

-- Full file paths are usually too much clutter.
-- https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using.html#ghc-flag--fhide-source-paths
:set -fhide-source-paths

-- Show type synonym expansions in error messages.
-- https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using.html#ghc-flag--fprint-expanded-synonyms
:set -fprint-expanded-synonyms

-- Collect type and location information after loading modules.
-- https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#ghci-cmd-:set%20+c
:set +c

-- Enable detection and handling of multiline expressions.
-- https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#ghci-cmd-:set%20+m
:set +m

-- Show types of evaluated expressions.
-- https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#ghci-cmd-:set%20+t
:set +t

-- -----------------------------------------------------------------------------

-- TODO: consider using these...

-- https://github.com/thumphries/dotfiles/blob/b4011c8305409e3b1f8aab547895f3a22c8f7ec2/ghc/.ghc/ghci.conf
-- :set -XAllowAmbiguousTypes
-- :set -fdefer-type-errors
-- :def rr \_ -> return ":set -fforce-recomp\n:reload\n:set -fno-force-recomp"
-- :def no-caret \_ -> return ":set -fno-diagnostics-show-caret"

-- -- Use the `OverloadedStrings` language extension.
-- -- https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-OverloadedStrings
-- :set -XOverloadedStrings

-- -- Scoped type variables is often useful so we can specify the types
-- -- of variables (for example, in lambda expressions).
-- :set -XScopedTypeVariables

-- -- useful for import from specified package
-- :set -XPackageImports

-- :set -XOverloadedLists
-- :set -XStandaloneDeriving

-- -- :set -package hlint
-- -- :set -package hi

-- -- :set -package haskell-docs

-- -- update tags
-- :def tags \_ -> return ":! haskdogs -- --ignore-close-implementation --etags"

-- :def doc \input -> return $ ":! haskell-docs " ++ input
