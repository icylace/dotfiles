-- https://typeclasses.com/ghci/config
-- https://downloads.haskell.org/~ghc/master/users-guide/using-warnings.html
-- https://medium.com/mercury-bank/enable-all-the-warnings-a0517bc081c3
-- https://gist.github.com/Pitometsu/0b0d04706e671172ed3b78309b14b43d

-- Options apparently get processed in this order:
--   1. A project's stack.yaml.
--   2. `--ghc-options` when running`stack ghci` on the command line.
--   3. `.ghci` settings (this file).

-- -----------------------------------------------------------------------------

-- Set the prompt text and colors.

:set prompt-function (\_ n -> return $ "\n\ESC[38;2;255;105;180m" ++ ["λ𝞴ᴧ𝚲𝛌𝛬Λ𝜆𝜦𝝀𝝠𝝺ƛ𝞚" !! mod n 14] ++ "  \ESC[m")

:set prompt-cont-function (\_ n -> return $ "\ESC[38;2;183;104;192m" ++ ["⋮︙⁞︰︓┆┇┋┊" !! mod n 9] ++ "  \ESC[m")

-- Enable all warnings so we can disable the ones we don't want.
-- https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Weverything
-- :set -Weverything
-- It's commented out here to avoid "resetting" a project's stack.yaml
-- warning settings.

-- -- `missing-exported-signatures` turns off the stricter `-Wmissing-signatures`.
-- -- https://ghc.haskell.org/trac/ghc/ticket/14794#ticket
-- :set -Wno-missing-exported-signatures

-- -- Explicit imports for every function (e.g. `$`) is too strict.
-- :set -Wno-missing-import-lists

-- -- When GHC can't specialize a polymorphic function.  No big deal and requires
-- -- fixing underlying libraries to solve.  Though, perhaps useful when
-- -- developing a performance critical library.
-- :set -Wno-all-missed-specialisations
-- :set -Wno-missed-specialisations

-- -- These are only useful if using Safe Haskell.
-- :set -Wno-trustworthy-safe
-- :set -Wno-safe
-- :set -Wno-unsafe

-- -- Polymorphic local bindings are harmless.
-- :set -Wno-missing-local-signatures

-- -- The monomorphism restriction adds confusion without being that impactful.
-- :set -Wno-monomorphism-restriction

-- -- Having the standard Prelude library implicitly available is convenient.
-- :set -Wno-implicit-prelude

-- -- `-Wtype-defaults` will complain about normal expressions like `5 + 5`.
-- :set -Wno-type-defaults

-- -- Show character ranges for errors.
-- -- https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html#ghc-flag--ferror-spans
-- :set -ferror-spans

-- -- Full file paths are usually too much clutter.
-- -- https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using.html#ghc-flag--fhide-source-paths
-- :set -fhide-source-paths

-- -- Show type synonym expansions in error messages.
-- -- https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using.html#ghc-flag--fprint-expanded-synonyms
-- :set -fprint-expanded-synonyms

-- Collect type and location information after loading modules.
-- https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#ghci-cmd-:set%20+c
:set +c

-- Enable detection and handling of multiline expressions.
-- https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#ghci-cmd-:set%20+m
:set +m

-- Show types of evaluated expressions.
-- https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#ghci-cmd-:set%20+t
:set +t

-- -- Use the `OverloadedStrings` language extension.
-- -- https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-OverloadedStrings
-- :set -XOverloadedStrings

-- -----------------------------------------------------------------------------


-- -- Treat all warnings like fatal errors.
-- -- https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Werror
-- :set -Werror





-- -- Scoped type variables is often useful so we can specify the types
-- -- of variables (for example, in lambda expressions).
-- :set -XScopedTypeVariables

-- -- useful for import from specified package
-- :set -XPackageImports

-- -- :set -package hscolour
-- -- :set -package ipprint
-- -- :set -package hlint
-- -- :set -package hi

-- -- :set -package hoogle
-- -- :set -package haskell-docs

-- -- give us a `hoogle` function to if the hoogle binary is available.
-- -- :def hoogle \s -> return $ ":! hoogle --count=15 \"" ++ s ++ "\""
-- let escape arg = "'" ++ ((\c -> if c == '\'' then "'\"'\"'" else [c]) =<< arg) ++"'"
-- :def! search return . (":!hoogle --count=50 --color " ++) . escape
-- :def! doc return . (":!hoogle --count=50 --color --info " ++) . escape



-- -- New current minimal config:

-- :set -XPackageImports
-- :def hoogle \x -> return $ ":! hoogle \"" ++ x ++ "\""
-- :def hoogle-info \x -> return $ ":! hoogle --info \"" ++ x ++ "\""

-- -- update tags
-- :def tags \_ -> return ":! haskdogs -- --ignore-close-implementation --etags"

-- -- update docs
-- :def docs \_ -> return ":! stack exec hoogle generate && stack hoogle --rebuild"

-- :def doc \input -> return $ ":! haskell-docs " ++ input


-- :set -XOverloadedStrings
-- :set -XOverloadedLists
-- :set -XScopedTypeVariables
-- :set -XPackageImports
-- :set -XStandaloneDeriving
