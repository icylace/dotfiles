:q
redundantCase false
redundantCase true
redundantCase false = false
redundantCase true = true
redundantCase :: Boolean -> Boolean
:p
:q
lzs [1, -1, -2, 3, 0, 1]
lzs [1, -1, -2, 3, 0]
lzs [1, -1, -2, 3]
lzs [1, 2, 3, 4]
           _ -> lzs (unsafePartial tail xs)
           0 -> xs
lzs xs = case sum xs of
lzs [] = []
lzs :: Array Int -> Array Int
:p
import Partial.Unsafe (unsafePartial)
import Data.Foldable (sum)
import Data.Array.Partial (tail)
:q
import Partial.Unsafe (unsafePartial)
import Data.Array.Partial (tail)
import Data.Array (sum)
:q
import Partial.Unsafe (unsafePartial)
import Data.Array.Partial (sum, tail)
:t sum
:q
           _ -> lzs (unsafePartial tail xs)
           0 -> xs
lzs xs = case sum xs of
lzs [] = []
lzs :: Array Int -> Array Int
:p
           _ -> lzs (unsafePartial tail xs)
           0 -> xs
lzs xs = case sum xs of
lzs [] = []
lzs :: Array Int -> Array Int
import Partial.Unsafe (unsafePartial)
import Data.Array.Partial (tail)
           _ -> lzs (unsafePartial tail xs)
           0 -> xs
lzs xs = case sum xs of
lzs [] = []
lzs :: Array Int -> Array Int
import Partial.Unsafe (unsafePartial)
import Data.Array.Partial (tail)
:p
:q
import Partial.Unsafe (unsafePartial)
import Data.Array.Partial (tail)
:q
takeFive 5635
takeFive []
takeFive [1, 2, 3, 4, 5]
takeFive [0, 1, 2, 3, 4]
takeFive _ = 0
takeFive [0, 1, a, b, _] = a * b
takeFive :: Array Int -> Int
:p
:q
:t true
:t True
:q
:t True
:t true
:t type
import Data.Boolean
:t type
:q
g n = n + 10
f n = n * n
g 1 = 3
f 1 = 3
g 0 = 1
g :: Int -> Int
f 0 = 1
f :: Int -> Int
:p
:q
g n = n + 10
f n = n * n
g 1 = 3
f 1 = 3
g 0 = 1
f 0 = 1
g :: Int -> Int
f :: Int -> Int
:p
:q
g n = n + 10
f n = n * n
g 1 = 3
f 1 = 3
g 0 = 1
f 0 = 1
g :: Int -> Int
